using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using RegressionGames;
using RegressionGames.RGBotConfigs;
using Unity.BossRoom.ConnectionManagement;
using Unity.BossRoom.Gameplay.GameplayObjects.Character;
using Unity.BossRoom.Gameplay.GameState;
using Unity.BossRoom.Infrastructure;
using RegressionGames.Types;
using Unity.BossRoom.Utils;
using Unity.Multiplayer.Samples.BossRoom;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.Assertions;
using Random = System.Random;

namespace Unity.BossRoom.Gameplay.RegressionGames
{
    public class RGBossRoomBotSpawnManager : RGBotSpawnManager
    {
        [SerializeField]
        [Tooltip("Regression Games Bot Prefab!")]
        private NetworkObject rgBotPrefab;
        
        private readonly ConcurrentDictionary<uint, NetworkObject> clientPlayerMap = new ConcurrentDictionary<uint, NetworkObject>();

        // client ids to spawn for
        private readonly ConcurrentQueue<Tuple<uint, string, string>> playersToSpawn = new ConcurrentQueue<Tuple<uint, string, string>>();
        
        private bool initialSpawnDone = false;

        /**
         * While we are using a threadsafe map, we still want to ensure that the initial spawn finishes before subsequent spawn requests
         */
        [MethodImpl(MethodImplOptions.Synchronized)]
        public override  void SpawnBots(bool lateJoin = false)
        {
            if (lateJoin && !initialSpawnDone)
            {
                // rg told us to spawn before the right scene.. ignore
                return; 
            }
            Tuple<uint, string,string> clientIdBotNamePlayerClass;
            while( playersToSpawn.TryDequeue(out clientIdBotNamePlayerClass) )
            {
                // make sure this client is still connected
                if (RGBotServerListener.GetInstance().IsClientConnected(clientIdBotNamePlayerClass.Item1))
                {
                    SpawnBot(lateJoin, clientIdBotNamePlayerClass.Item1, clientIdBotNamePlayerClass.Item2,
                        clientIdBotNamePlayerClass.Item3);
                }
            }
            initialSpawnDone = true;
        }

        public override void TeardownBot(uint clientId)
        {
            if (clientPlayerMap.TryRemove(clientId, out NetworkObject pp))
            {
                try
                {
                    pp.Despawn(true);
                }
                catch (Exception)
                {
                    RGDebug.Log($"Player already de-spawned");
                }

            }

            try
            {
                ServerCharSelectState charSelectState =
                    FindObjectOfType<ServerCharSelectState>();
                if (charSelectState != null)
                {
                    charSelectState.OnClientChangedSeat(clientId, -1, false);
                    // remove the bot from the lobby
                    charSelectState.OnClientDisconnectCallback(clientId);
                }

                SessionManager<SessionPlayerData>.Instance.DisconnectClient(clientId);
            }
            catch (Exception e)
            {
                RGDebug.LogException(new Exception("Error removing bot from lobby", e));
            }
            
        }

        public override void StopGame()
        {
            // if there is somehow still player objects left, kill them
            foreach (uint key in clientPlayerMap.Keys)
            {
                RGBotServerListener.GetInstance().EndClientConnection(key);
                TeardownBot(key);
            }
            clientPlayerMap.Clear();
            playersToSpawn.Clear();
            initialSpawnDone = false;
        }

        public override void SpawnBot(bool lateJoin, uint clientId, string botName, string characterType)
        {
            RGDebug.Log($"Trying to spawn RG Bot for clientId: {clientId}");
            // make sure they don't already have a bot
            if (!clientPlayerMap.ContainsKey(clientId))
            {
                ServerBossRoomState serverBossRoomState = FindObjectOfType<ServerBossRoomState>();

                Transform spawnPoint = serverBossRoomState.getNextSpawnPoint();

                var newPlayer = Instantiate(rgBotPrefab, Vector3.zero, Quaternion.identity);

                var newPlayerCharacter = newPlayer.GetComponent<ServerCharacter>();

                var physicsTransform = newPlayerCharacter.physicsWrapper.Transform;

                if (spawnPoint != null)
                {
                    physicsTransform.SetPositionAndRotation(spawnPoint.position, spawnPoint.rotation);
                }

                // pass character type from persistent player to avatar
                var networkAvatarGuidStateExists =
                    newPlayer.TryGetComponent(out NetworkAvatarGuidState networkAvatarGuidState);

                Assert.IsTrue(networkAvatarGuidStateExists,
                    $"NetworkCharacterGuidState not found on player avatar!");

                // if reconnecting, set the player's position and rotation to its previous state
                if (lateJoin)
                {
                    SessionPlayerData? sessionPlayerData = SessionManager<SessionPlayerData>.Instance.GetPlayerData(clientId);
                    if (sessionPlayerData is { HasCharacterSpawned: true })
                    {
                        physicsTransform.SetPositionAndRotation(sessionPlayerData.Value.PlayerPosition, sessionPlayerData.Value.PlayerRotation);
                    }
                }
                
                // DOING THIS BEFORE SPAWN CAUSES A WARNING, BUT IT MUST BE DONE BEFORE SPAWN...
                // "NetworkVariable is written to, but doesn't know its NetworkBehaviour yet. Are you modifying a NetworkVariable before the NetworkObject is spawned?"
                //
                // Deterministic avatars
                //         Tank,
                // Archer,
                // Mage,
                // Rogue,
                if (Enum.TryParse(characterType, out CharacterTypeEnum charType))
                {
                    RGDebug.Log($"Setting bot character type: {characterType}");   
                    networkAvatarGuidState.SetAvatarMatchingCharacterType(charType);
                }
                else
                {
                    RGDebug.Log($"Setting bot character type: RANDOM");
                    networkAvatarGuidState.SetRandomAvatar();
                }

                // spawn players characters with destroyWithScene = true
                newPlayer.Spawn(true);

                // pass name from persistent player to avatar
                if (newPlayer.TryGetComponent(out NetworkNameState networkNameState))
                {
                    networkNameState.Name.Value = botName;
                }
                
                // Add the clientPlayer ref
                clientPlayerMap[clientId] = newPlayer;

            }
            else if (initialSpawnDone)
            {
                if (!clientPlayerMap[clientId].IsSpawned)
                {
                    clientPlayerMap[clientId].Spawn();
                }
            }
            
            RGBotServerListener rgBotServerListener = RGBotServerListener.GetInstance();
            if (rgBotServerListener != null)
            {
                // Add the agent
                rgBotServerListener.agentMap[clientId] = clientPlayerMap[clientId].GetComponent<RGAgent>();

                RGDebug.Log($"Sending playerId to client: {clientId}");
                // Send the client their player Id
                rgBotServerListener.SendToClient(clientId, "playerId",
                    JsonUtility.ToJson(
                        new RGServerPlayerId(clientPlayerMap[clientId].transform.GetInstanceID())));
            }
        }
        
        public override int? GetPlayerId(uint clientId)
        {
            return clientPlayerMap[clientId]?.transform.GetInstanceID();
        }

        public override void SeatPlayer(uint clientId, string clientSpecifiedCharacterType, string botName)
        {
            // sometimes the client can reconnect twice in rapid succession.. makes sure it only processes 1 at at time
            lock (string.Intern($"{clientId}"))
            {
                SessionPlayerData? sessionPlayerData =
                    SessionManager<SessionPlayerData>.Instance.GetPlayerData(clientId);

                string characterType = null;
                // try to keep our player class the same on reconnects where the bot was randomly assigned one
                if (clientPlayerMap.TryGetValue(clientId, out NetworkObject clientNetObject))
                {
                    if (clientNetObject.TryGetComponent(out NetworkAvatarGuidState networkAvatarGuidState))
                    {
                        CharacterTypeEnum? charType =
                            networkAvatarGuidState.RegisteredAvatar?.CharacterClass?.CharacterType;
                        if (charType != null)
                        {
                            characterType = charType.ToString();
                        }
                    }
                }

                if (characterType == null)
                {
                    characterType = clientSpecifiedCharacterType;
                }

                // add them to the server session if they haven't connected before
                if (sessionPlayerData == null)
                {
                    SessionManager<SessionPlayerData>.Instance.SetupConnectingPlayerSessionData(clientId,
                        botName,
                        new SessionPlayerData(clientId, botName, new NetworkGuid(), 0, true));

                    ServerCharSelectState charSelectState = FindObjectOfType<ServerCharSelectState>();
                    if (charSelectState != null)
                    {
                        // pick which seat
                        List<int> availableSeats = charSelectState.FindAvailableSeatIndexes();
                        if (availableSeats.Count > 0)
                        {

                            // seat the player
                            charSelectState.SeatNewPlayer(clientId);

                            // we let there be bots that don't match the available char types for the seats 
                            // (2 tanks, 2 archers, 2 mages, 2 rogues), but we still make a best effort to
                            // assign the bots to matching seats when possible

                            int seat = -1;
                            switch (characterType)
                            {
                                case "Tank":
                                    if (availableSeats.Contains(0))
                                    {
                                        seat = 0;
                                    }
                                    else if (availableSeats.Contains(1))
                                    {
                                        seat = 1;
                                    }

                                    break;
                                case "Archer":
                                    if (availableSeats.Contains(2))
                                    {
                                        seat = 2;
                                    }
                                    else if (availableSeats.Contains(3))
                                    {
                                        seat = 3;
                                    }

                                    break;
                                case "Mage":
                                    if (availableSeats.Contains(4))
                                    {
                                        seat = 4;
                                    }
                                    else if (availableSeats.Contains(5))
                                    {
                                        seat = 5;
                                    }

                                    break;
                                case "Rogue":
                                    if (availableSeats.Contains(6))
                                    {
                                        seat = 6;
                                    }
                                    else if (availableSeats.Contains(7))
                                    {
                                        seat = 7;
                                    }

                                    break;
                            }

                            if (seat < 0)
                            {
                                // just take a random seat.. we didn't have an opening matching our player class :/
                                seat = availableSeats[new Random().Next(0, availableSeats.Count)];
                            }

                            charSelectState.OnClientChangedSeat(clientId, seat, true);

                            RGBotServerListener rgBotServerListener = RGBotServerListener.GetInstance();
                            if (rgBotServerListener != null)
                            {
                                RGDebug.Log($"Sending socket handshake response to client id: {clientId}");
                                //send the client a handshake response so they can start processing
                                rgBotServerListener.SendHandshakeResponseToClient(clientId, characterType);
                            }


                        }
                        else
                        {
                            RGBotServerListener rgBotServerListener = RGBotServerListener.GetInstance();
                            if (rgBotServerListener != null)
                            {
                                RGDebug.Log($"Sending ERROR socket handshake response to client id: {clientId}");
                                //send the client an ERROR handshake response so they can start processing
                                rgBotServerListener.SendHandshakeResponseToClient(clientId, null,
                                    "No seats available for bot connection.");
                            }
                        }
                    }
                    else
                    {
                        // late join
                        RGBotServerListener rgBotServerListener = RGBotServerListener.GetInstance();
                        if (rgBotServerListener != null)
                        {
                            RGDebug.Log($"Sending socket handshake response to client id: {clientId}");
                            //send the client an ERROR handshake response so they can start processing
                            rgBotServerListener.SendHandshakeResponseToClient(clientId, characterType);
                        }
                    }

                }
                else
                {
                    // reconnecting
                    RGBotServerListener rgBotServerListener = RGBotServerListener.GetInstance();
                    if (rgBotServerListener != null)
                    {
                        RGDebug.Log($"Sending socket handshake response to client id: {clientId}");
                        //send the client a handshake response so they can start processing
                        rgBotServerListener.SendHandshakeResponseToClient(clientId, characterType);
                        if (clientPlayerMap.TryGetValue(clientId, out NetworkObject netObj))
                        {
                            RGDebug.Log($"Sending playerId to client: {clientId}");
                            // Send the client their player Id
                            rgBotServerListener.SendToClient(clientId, "playerId",
                                JsonUtility.ToJson(
                                    new RGServerPlayerId(netObj.transform.GetInstanceID())));
                        }
                    }
                }

                // setup this action to happen on the next main thread update
                playersToSpawn.Enqueue(new Tuple<uint, string, string>(clientId, botName, characterType));
            }
        }

    }
}
